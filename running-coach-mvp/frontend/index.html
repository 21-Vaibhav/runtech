<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RunTech Coach Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg: #06090f;
      --bg-2: #0d1420;
      --panel: #121d2d;
      --panel-2: #16263a;
      --line: #2a415f;
      --text: #edf5ff;
      --muted: #9fb2cc;
      --good: #5bf3b0;
      --warn: #ffd27a;
      --risk: #ff8594;
      --accent: #62d9ff;
      --radius: 16px;
      --shadow: 0 12px 40px rgba(0, 0, 0, 0.34);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--text);
      font-family: "Segoe UI", Tahoma, sans-serif;
      background:
        radial-gradient(1200px 600px at 100% -10%, rgba(98, 217, 255, 0.14), transparent 60%),
        radial-gradient(700px 420px at -15% 30%, rgba(91, 243, 176, 0.11), transparent 56%),
        linear-gradient(170deg, var(--bg), var(--bg-2));
      min-height: 100vh;
    }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 30;
      backdrop-filter: blur(8px);
      background: rgba(6, 9, 15, 0.72);
      border-bottom: 1px solid rgba(42, 65, 95, 0.55);
    }

    .topbar-inner {
      width: min(1240px, 96vw);
      margin: 0 auto;
      padding: 10px 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .brand { font-weight: 800; letter-spacing: 0.02em; }
    .status { display: inline-flex; align-items: center; gap: 8px; color: var(--muted); font-size: 0.88rem; }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--good);
      box-shadow: 0 0 15px rgba(91, 243, 176, 0.6);
    }
    .dot.warn { background: var(--warn); box-shadow: 0 0 15px rgba(255, 210, 122, 0.6); }
    .dot.bad { background: var(--risk); box-shadow: 0 0 15px rgba(255, 133, 148, 0.6); }

    .progress {
      position: fixed;
      top: 0;
      left: 0;
      width: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), var(--good));
      box-shadow: 0 0 20px rgba(98, 217, 255, 0.7);
      transition: width 160ms linear, opacity 260ms;
      opacity: 0;
      z-index: 99;
    }
    body.busy .progress { opacity: 1; }

    .wrap {
      width: min(1240px, 96vw);
      margin: 18px auto 36px;
      display: grid;
      gap: 14px;
    }

    .card {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .hero {
      display: grid;
      grid-template-columns: 1.25fr 1fr;
      gap: 14px;
    }
    .hero h1 { margin: 0; font-size: clamp(1.3rem, 2.2vw, 2rem); }
    .hero p { margin: 8px 0 0; color: var(--muted); line-height: 1.45; max-width: 70ch; }

    .kpis {
      display: grid;
      grid-template-columns: repeat(2, minmax(120px, 1fr));
      gap: 9px;
      align-content: start;
    }
    .kpi {
      border: 1px solid #355273;
      border-radius: 12px;
      background: rgba(5, 14, 26, 0.45);
      padding: 10px;
    }
    .kpi .label { color: var(--muted); font-size: 0.74rem; text-transform: uppercase; letter-spacing: 0.06em; }
    .kpi .value { margin-top: 4px; font-size: 1.15rem; font-weight: 800; }

    .main {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 14px;
    }
    .stack { display: grid; gap: 14px; }
    h2 { margin: 0 0 10px; font-size: 1rem; letter-spacing: 0.01em; }

    .controls label { display: block; color: var(--muted); font-size: 0.74rem; margin-bottom: 4px; }
    .controls input {
      width: 100%;
      border: 1px solid #32506f;
      border-radius: 10px;
      padding: 9px 10px;
      background: #0a1524;
      color: var(--text);
      margin-bottom: 8px;
      font: inherit;
    }

    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    button {
      border: none;
      border-radius: 10px;
      padding: 10px;
      font: inherit;
      font-weight: 700;
      cursor: pointer;
      color: #0a2233;
      background: linear-gradient(90deg, var(--accent), #9aefff);
    }
    button.soft { background: linear-gradient(90deg, #a3d7ff, #b5ffd7); }
    button.warn { background: linear-gradient(90deg, #ffd58d, #ffe9ba); color: #3c2a0b; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    .recommend {
      border: 1px solid #36597b;
      border-radius: 14px;
      background: rgba(98, 217, 255, 0.12);
      padding: 12px;
    }
    .recommend .title { color: var(--muted); font-size: 0.77rem; text-transform: uppercase; letter-spacing: 0.06em; }
    .recommend .action { margin-top: 4px; font-size: 1.65rem; font-weight: 900; letter-spacing: 0.02em; }
    .recommend .meta { margin-top: 6px; color: #d9ecff; font-size: 0.9rem; }

    .badge {
      display: inline-block;
      margin-top: 8px;
      border-radius: 999px;
      border: 1px solid #3d6488;
      padding: 4px 10px;
      font-size: 0.8rem;
      color: #b6ddff;
      background: rgba(98, 217, 255, 0.12);
    }
    .badge.ready { border-color: #3f9369; color: #95ffd0; background: rgba(91, 243, 176, 0.16); }
    .badge.steady { border-color: #8f7a45; color: #ffe6a1; background: rgba(255, 210, 122, 0.15); }
    .badge.caution { border-color: #955664; color: #ffc6d0; background: rgba(255, 133, 148, 0.16); }

    .reason, .narrative {
      margin-top: 8px;
      border: 1px solid #304f70;
      border-radius: 10px;
      background: #0b1423;
      color: #d5eaff;
      padding: 10px;
      font-size: 0.84rem;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .chart-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }
    .chart-wrap { height: 220px; }
    .chart-note {
      margin-top: 6px;
      color: var(--muted);
      font-size: 0.76rem;
    }

    .chips { display: flex; flex-wrap: wrap; gap: 7px; margin-top: 8px; }
    .chip {
      border: 1px solid #35597b;
      border-radius: 999px;
      padding: 4px 9px;
      font-size: 0.76rem;
      color: #c5e4ff;
      background: rgba(98, 217, 255, 0.1);
    }

    .feedback {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 10px;
    }

    .explain details {
      border: 1px solid #314f6f;
      border-radius: 10px;
      padding: 9px 10px;
      background: rgba(7, 16, 28, 0.6);
      margin-top: 8px;
    }
    .explain summary { cursor: pointer; font-weight: 700; color: #c9e6ff; }
    .explain p { margin: 8px 0 0; color: var(--muted); font-size: 0.85rem; line-height: 1.45; }

    .skeleton {
      position: relative;
      overflow: hidden;
      color: transparent !important;
      background: #152438 !important;
    }
    .skeleton::after {
      content: "";
      position: absolute;
      inset: 0;
      transform: translateX(-100%);
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.08), transparent);
      animation: shimmer 1.2s infinite;
    }
    @keyframes shimmer { 100% { transform: translateX(100%); } }

    .output {
      margin-top: 10px;
      border: 1px solid #324f70;
      border-radius: 10px;
      background: #0b1423;
      color: #d5eaff;
      padding: 10px;
      font-size: 0.78rem;
      max-height: 240px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    @media (max-width: 1080px) {
      .hero { grid-template-columns: 1fr; }
      .main { grid-template-columns: 1fr; }
      .chart-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div id="progress" class="progress"></div>
  <header class="topbar">
    <div class="topbar-inner">
      <div class="brand">RunTech Coach</div>
      <div class="status"><span id="statusDot" class="dot"></span><span id="statusText">Ready</span></div>
    </div>
  </header>

  <main class="wrap">
    <section class="card hero">
      <div>
        <h1>Training Decision Dashboard</h1>
        <p>
          This tool syncs your Strava training, computes fitness/fatigue state, then recommends your safest next session.
          Workflow: connect once, sync, update state cache, then request recommendation.
        </p>
      </div>
      <div class="kpis">
        <div class="kpi"><div class="label">Readiness</div><div id="kReadiness" class="value skeleton">steady</div></div>
        <div class="kpi"><div class="label">Form</div><div id="kForm" class="value skeleton">0.0</div></div>
        <div class="kpi"><div class="label">ACWR</div><div id="kAcwr" class="value skeleton">1.00</div></div>
        <div class="kpi"><div class="label">Sessions (7d)</div><div id="kSessions" class="value skeleton">0</div></div>
      </div>
    </section>

    <section class="main">
      <aside class="stack">
        <section class="card controls">
          <h2>One-Click Flow</h2>
          <label for="apiBase">API base URL</label>
          <input id="apiBase" value="" placeholder="Auto: current deployment origin" />
          <label for="daysBack">Sync history (days)</label>
          <input id="daysBack" type="number" min="1" max="365" value="90" />

          <div class="btn-grid">
            <button data-action id="fullFlowBtn">Connect + Sync + Recommend</button>
            <button data-action id="refreshBtn" class="soft">Refresh Dashboard</button>
          </div>

          <pre id="apiOut" class="output">Output logs...</pre>
        </section>

        <section class="card explain">
          <h2>Beginner Guide</h2>
          <details open><summary>Why this recommendation?</summary><p>It maximizes fitness gain while reducing fatigue and injury risk, using your recent training load and recovery state.</p></details>
          <details><summary>What is ACWR?</summary><p>ACWR is your last 7 days load divided by last 28 days load. Above ~1.5 means your recent load likely spiked too fast.</p></details>
          <details><summary>What is Form?</summary><p>Form = Fitness - Fatigue. Positive form means fresher; very negative form means your body may need easier training.</p></details>
          <details><summary>Why hard sessions can be blocked</summary><p>Hard or moderate can be blocked by high ACWR, fatigue confidence bounds, or race taper constraints.</p></details>
        </section>
      </aside>

      <section class="stack">
        <section class="card">
          <h2>Today Recommendation</h2>
          <div class="recommend">
            <div class="title">Action</div>
            <div id="recAction" class="action">Not generated</div>
            <div id="recMeta" class="meta">Press Get Recommendation after state update.</div>
          </div>
          <div id="readinessBadge" class="badge">Readiness: unknown</div>
          <div id="recReason" class="reason">Reasoning appears here.</div>
          <div id="narrative" class="narrative">Narrative explanation appears here.</div>

          <h2 style="margin-top:12px;">Feedback (what you actually did)</h2>
          <div class="feedback">
            <button data-action class="soft feedback-btn" data-act="rest">Rest</button>
            <button data-action class="soft feedback-btn" data-act="easy">Easy</button>
            <button data-action class="soft feedback-btn" data-act="moderate">Moderate</button>
            <button data-action class="soft feedback-btn" data-act="hard">Hard</button>
          </div>
        </section>

        <section class="card">
          <h2>Trends</h2>
          <div class="chart-grid">
            <div>
              <div class="chart-wrap"><canvas id="stateChart"></canvas></div>
              <div id="stateChartNote" class="chart-note"></div>
            </div>
            <div>
              <div class="chart-wrap"><canvas id="loadChart"></canvas></div>
              <div id="loadChartNote" class="chart-note"></div>
            </div>
            <div>
              <div class="chart-wrap"><canvas id="acwrChart"></canvas></div>
              <div id="acwrChartNote" class="chart-note"></div>
            </div>
          </div>
          <div class="chips" id="activityMix"></div>
        </section>
      </section>
    </section>
  </main>

  <script>
    const $ = (id) => document.getElementById(id);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    const appState = {
      busy: false,
      progress: 0,
      progressTimer: null,
      latestRecommendation: null,
      charts: { state: null, load: null, acwr: null },
      oauthResolve: null,
      oauthReject: null,
      currentUserId: null,
    };

    const ui = {
      progress: $("progress"),
      statusText: $("statusText"),
      statusDot: $("statusDot"),
      apiBase: $("apiBase"),
      daysBack: $("daysBack"),
      apiOut: $("apiOut"),
      kReadiness: $("kReadiness"),
      kForm: $("kForm"),
      kAcwr: $("kAcwr"),
      kSessions: $("kSessions"),
      recAction: $("recAction"),
      recMeta: $("recMeta"),
      readinessBadge: $("readinessBadge"),
      recReason: $("recReason"),
      narrative: $("narrative"),
      activityMix: $("activityMix"),
      stateChartNote: $("stateChartNote"),
      loadChartNote: $("loadChartNote"),
      acwrChartNote: $("acwrChartNote"),
    };

    const runtimeBase =
      (window.location.protocol === "http:" || window.location.protocol === "https:")
        ? window.location.origin
        : "http://localhost:8000";
    const isDeployedHost = !["localhost", "127.0.0.1"].includes(window.location.hostname);
    const savedBase = localStorage.getItem("rc_api_base");
    if (savedBase && !(isDeployedHost && savedBase.includes("localhost"))) {
      ui.apiBase.value = savedBase;
    } else {
      ui.apiBase.value = runtimeBase;
      localStorage.setItem("rc_api_base", runtimeBase);
    }

    function sessionToken() {
      return localStorage.getItem("rc_session_token") || "";
    }

    function setSessionToken(token, expiresAt) {
      if (token) localStorage.setItem("rc_session_token", token);
      if (expiresAt) localStorage.setItem("rc_session_expires_at", String(expiresAt));
    }

    function clearSessionToken() {
      localStorage.removeItem("rc_session_token");
      localStorage.removeItem("rc_session_expires_at");
    }

    function apiBase() {
      const v = (ui.apiBase.value.trim() || runtimeBase).replace(/\/$/, "");
      localStorage.setItem("rc_api_base", v);
      return v;
    }

    function setStatus(text, tone = "good") {
      ui.statusText.textContent = text;
      ui.statusDot.className = `dot ${tone === "good" ? "" : tone}`.trim();
    }

    function applyOAuthSuccess(payload) {
      if (payload && payload.user_id) {
        appState.currentUserId = Number(payload.user_id);
      }
      if (payload && payload.session_token) {
        setSessionToken(payload.session_token, payload.session_expires_at);
      }
      localStorage.removeItem("rc_oauth_state");
      ui.apiOut.textContent = JSON.stringify(payload || { ok: true }, null, 2);
      setStatus("Strava connected. You can sync now.", "good");
      refreshDashboard().catch(() => {});
    }

    function setBusy(on, label = "Working...") {
      appState.busy = on;
      document.body.classList.toggle("busy", on);
      for (const btn of $$("button[data-action]")) {
        btn.disabled = on;
      }
      if (on) {
        setStatus(label, "warn");
        appState.progress = 10;
        ui.progress.style.width = `${appState.progress}%`;
        if (appState.progressTimer) clearInterval(appState.progressTimer);
        appState.progressTimer = setInterval(() => {
          appState.progress = Math.min(92, appState.progress + Math.max(1, (98 - appState.progress) * 0.08));
          ui.progress.style.width = `${appState.progress}%`;
        }, 170);
      } else {
        if (appState.progressTimer) clearInterval(appState.progressTimer);
        appState.progressTimer = null;
        ui.progress.style.width = "100%";
        setTimeout(() => { ui.progress.style.width = "0%"; }, 230);
      }
    }

    function clearSkeletons() {
      for (const el of [ui.kReadiness, ui.kForm, ui.kAcwr, ui.kSessions]) {
        el.classList.remove("skeleton");
      }
    }

    async function request(path, options = {}) {
      const headers = new Headers(options.headers || {});
      const token = sessionToken();
      if (token) headers.set("Authorization", `Bearer ${token}`);
      const response = await fetch(`${apiBase()}${path}`, { ...options, headers });
      const raw = await response.text();
      if (!response.ok) {
        let detail = raw;
        try { detail = JSON.parse(raw).detail || raw; } catch (_) {}
        if (response.status === 401) {
          clearSessionToken();
        }
        throw new Error(`${response.status}: ${detail}`);
      }
      return raw ? JSON.parse(raw) : {};
    }

    function renderRecommendation(payload) {
      if (!payload || !payload.recommended_action) return;
      appState.latestRecommendation = payload;
      const reason = payload.reasoning_dict || {};
      ui.recAction.textContent = String(payload.recommended_action).toUpperCase();
      ui.recMeta.textContent = `Confidence ${Number(payload.confidence_score || 0).toFixed(2)} | Form ${Number(reason.form || 0).toFixed(1)} | ACWR ${Number(reason.acwr || 0).toFixed(2)}`;
      ui.recReason.textContent = `Blocked actions: ${(reason.blocked_actions || []).join(", ") || "none"}\nConstraint reasons: ${(reason.hard_constraint_reasons || []).join(", ") || "none"}`;
      ui.narrative.textContent = payload.narrative || "No narrative generated.";
    }

    function destroyChart(chart) {
      if (chart) chart.destroy();
    }

    function renderCharts(dashboard) {
      let stateTrend = dashboard?.trends?.state || [];
      let acwrTrend = dashboard?.trends?.acwr || [];
      const loadTrend = dashboard?.trends?.weekly_load || [];

      const today = dashboard?.today || new Date().toISOString().slice(0, 10);
      if (!stateTrend.length && dashboard?.state) {
        stateTrend = [{
          date: today,
          fitness: Number(dashboard.state.fitness || 0),
          fatigue: Number(dashboard.state.fatigue || 0),
          form: Number(dashboard.state.form || 0),
        }];
      }
      if (!acwrTrend.length && typeof dashboard?.acwr === "number") {
        acwrTrend = [{ date: today, value: Number(dashboard.acwr || 0) }];
      }

      const stateLabels = stateTrend.map((x) => x.date);
      const fitnessData = stateTrend.map((x) => Number(x.fitness || 0));
      const fatigueData = stateTrend.map((x) => Number(x.fatigue || 0));
      const acwrLabels = acwrTrend.map((x) => x.date);
      const acwrData = acwrTrend.map((x) => Number(x.value || 0));
      const loadLabels = loadTrend.map((x) => x.week);
      const loadData = loadTrend.map((x) => Number(x.value || 0));

      ui.stateChartNote.textContent = stateTrend.length <= 1
        ? "Only one state snapshot available. Run sync + update state on more days to see trend lines."
        : "";
      ui.acwrChartNote.textContent = acwrTrend.length <= 1
        ? "ACWR trend needs more daily load history. Current value is shown."
        : "";
      ui.loadChartNote.textContent = loadTrend.length <= 1
        ? "Weekly load builds as more sessions are synced."
        : "";

      destroyChart(appState.charts.state);
      destroyChart(appState.charts.acwr);
      destroyChart(appState.charts.load);

      const statePointRadius = stateTrend.length <= 2 ? 4 : 0;
      const acwrPointRadius = acwrTrend.length <= 2 ? 4 : 0;

      appState.charts.state = new Chart($("stateChart"), {
        type: "line",
        data: {
          labels: stateLabels,
          datasets: [
            { label: "Fitness", data: fitnessData, borderColor: "#62d9ff", tension: 0.3, pointRadius: statePointRadius },
            { label: "Fatigue", data: fatigueData, borderColor: "#ff8594", tension: 0.3, pointRadius: statePointRadius },
          ],
        },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: "#dcecff" } } }, scales: { x: { ticks: { color: "#96abc7" } }, y: { ticks: { color: "#96abc7" } } } },
      });

      appState.charts.load = new Chart($("loadChart"), {
        type: "bar",
        data: { labels: loadLabels, datasets: [{ label: "Weekly Load", data: loadData, backgroundColor: "rgba(91,243,176,0.6)", borderColor: "#5bf3b0", borderWidth: 1 }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: "#dcecff" } } }, scales: { x: { ticks: { color: "#96abc7" } }, y: { ticks: { color: "#96abc7" } } } },
      });

      appState.charts.acwr = new Chart($("acwrChart"), {
        type: "line",
        data: {
          labels: acwrLabels,
          datasets: [
            { label: "ACWR", data: acwrData, borderColor: "#ffd27a", backgroundColor: "rgba(255,210,122,0.2)", fill: true, tension: 0.28, pointRadius: acwrPointRadius },
            { label: "Risk 1.5", data: acwrLabels.map(() => 1.5), borderColor: "rgba(255,133,148,0.9)", borderDash: [6, 5], pointRadius: 0 },
          ],
        },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: "#dcecff" } } }, scales: { x: { ticks: { color: "#96abc7" } }, y: { min: 0, ticks: { color: "#96abc7" } } } },
      });
    }

    function renderDashboard(data) {
      clearSkeletons();
      const weekly = data.weekly || {};
      const state = data.state || {};
      const readiness = data.readiness || "unknown";

      ui.kReadiness.textContent = readiness;
      ui.kForm.textContent = Number(state.form || 0).toFixed(1);
      ui.kAcwr.textContent = Number(data.acwr || 0).toFixed(2);
      ui.kSessions.textContent = String(weekly.sessions || 0);

      ui.readinessBadge.className = `badge ${readiness}`;
      ui.readinessBadge.textContent = `Readiness: ${readiness}`;

      const mix = weekly.activity_mix || {};
      ui.activityMix.innerHTML = "";
      const entries = Object.entries(mix);
      if (!entries.length) {
        const empty = document.createElement("span");
        empty.className = "chip";
        empty.textContent = "No activities in last 7 days";
        ui.activityMix.appendChild(empty);
      } else {
        for (const [k, v] of entries) {
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.textContent = `${k}: ${v}`;
          ui.activityMix.appendChild(chip);
        }
      }

      const latest = data.latest_recommendation;
      if (latest && latest.action) {
        renderRecommendation({
          recommended_action: latest.action,
          confidence_score: latest.confidence,
          reasoning_dict: latest.reasoning || {},
          narrative: appState.latestRecommendation?.narrative || ui.narrative.textContent,
        });
      }

      renderCharts(data);
    }

    async function run(label, fn) {
      if (appState.busy) return;
      setBusy(true, label);
      try {
        await fn();
      } catch (error) {
        ui.apiOut.textContent = String(error);
        setStatus(String(error), "bad");
      } finally {
        setBusy(false);
      }
    }

    async function refreshDashboard() {
      if (!appState.currentUserId) {
        throw new Error("Not connected yet. Click Connect + Sync + Recommend first.");
      }
      const data = await request(`/dashboard/${appState.currentUserId}`);
      ui.apiOut.textContent = JSON.stringify(data, null, 2);
      renderDashboard(data);
      setStatus("Dashboard updated", "good");
    }

    function waitForOAuthCompletion(timeoutMs = 180000) {
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          appState.oauthResolve = null;
          appState.oauthReject = null;
          reject(new Error("Authorization timed out. Please retry and complete Strava consent."));
        }, timeoutMs);
        appState.oauthResolve = (payload) => {
          clearTimeout(timer);
          appState.oauthResolve = null;
          appState.oauthReject = null;
          resolve(payload);
        };
        appState.oauthReject = (error) => {
          clearTimeout(timer);
          appState.oauthResolve = null;
          appState.oauthReject = null;
          reject(new Error(error || "OAuth failed."));
        };
      });
    }

    async function connectIfNeeded(popup) {
      if (sessionToken()) {
        try {
          const me = await request("/me");
          if (me && me.id) {
            appState.currentUserId = Number(me.id);
            return Number(me.id);
          }
        } catch (_) {
          clearSessionToken();
        }
      }

      const authData = await request("/auth/url");
      if (!authData.url) {
        throw new Error("Auth URL not returned by backend.");
      }
      if (authData.state) localStorage.setItem("rc_oauth_state", authData.state);
      if (!popup) {
        window.location.href = authData.url;
        throw new Error("Browser blocked popup. Please allow popups and retry.");
      }
      popup.location.href = authData.url;
      setStatus("Complete Strava authorization in the popup...", "warn");
      const authResult = await waitForOAuthCompletion();
      applyOAuthSuccess(authResult || {});
      return Number((authResult || {}).user_id || appState.currentUserId || 1);
    }

    async function runFullFlow(popup) {
      const activeUserId = await connectIfNeeded(popup);

      const syncPayload = await request("/sync", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: activeUserId, days_back: Number(ui.daysBack.value || 90) }),
      });
      ui.apiOut.textContent = JSON.stringify(syncPayload, null, 2);

      await request(`/state/update/${activeUserId}`, { method: "POST" });
      const recPayload = await request(`/recommend/${activeUserId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ model: "kalman" }),
      });
      renderRecommendation(recPayload);
      await refreshDashboard();
      setStatus("Full flow complete: connected, synced, and recommended.", "good");
    }

    window.addEventListener("message", (event) => {
      if (event.origin !== window.location.origin) return;
      const msg = event.data || {};
      if (msg.type === "running_coach_oauth_success") {
        applyOAuthSuccess(msg.payload || {});
        if (appState.oauthResolve) appState.oauthResolve(msg.payload || {});
      } else if (msg.type === "running_coach_oauth_error") {
        ui.apiOut.textContent = JSON.stringify(msg, null, 2);
        setStatus(msg.error || "OAuth failed", "bad");
        if (appState.oauthReject) appState.oauthReject(msg.error || "OAuth failed");
      }
    });

    $("fullFlowBtn").addEventListener("click", () => {
      const popup = window.open("", "running_coach_oauth", "width=520,height=760");
      run("Running full flow...", async () => runFullFlow(popup));
    });

    $("refreshBtn").addEventListener("click", () => run("Refreshing dashboard...", refreshDashboard));

    for (const btn of $$(".feedback-btn")) {
      btn.addEventListener("click", () => run("Submitting feedback...", async () => {
        const action = btn.dataset.act;
        const today = new Date().toISOString().slice(0, 10);
        const activeUserId = await connectIfNeeded(null);
        const payload = await request("/feedback", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            user_id: activeUserId,
            feedback_date: today,
            actual_action: action,
            observed_outcome: {},
          }),
        });
        ui.apiOut.textContent = JSON.stringify(payload, null, 2);
        setStatus(`Feedback logged: ${action}`, "good");
      }));
    }

    run("Loading dashboard...", refreshDashboard);
  </script>
</body>
</html>
